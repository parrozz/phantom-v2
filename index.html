<!-- Fond sombre + safe-area iOS -->
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0B0B14">
<style>
  html, body { margin:0; background:#0B0B14 !important; color-scheme: dark; }
  body {
    padding-top: env(safe-area-inset-top);
    padding-right: env(safe-area-inset-right);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    overflow-x: hidden;
  }
  /* on neutralise les grands wrappers externes bleus */
  :is(body>div, body>main, body>section, #__next, #__next>div){ background:#0B0B14 !important; }
  #phantom-fit-wrap{ width:100%; display:flex; justify-content:center; }
</style>

<script>
(() => {
  // ----- Réglages (tu peux ajuster si besoin) -----
  const MAX_SCALE = 3;    // limite pour éviter un zoom "gigantesque" sur très grands écrans
  const MIN_WIDTH = 320;  // largeur min raisonnable pour la colonne cible
  const MAX_WIDTH = 900;  // largeur max raisonnable pour la colonne cible

  // Si tu connais un sélecteur fiable de la colonne centrale, mets-le ici :
  const CUSTOM_SELECTOR = ''; // ex: '.max-w-md.mx-auto' ; sinon on auto-détecte

  function findTarget(){
    if (CUSTOM_SELECTOR) {
      const el = document.querySelector(CUSTOM_SELECTOR);
      if (el) return el;
    }
    // Heuristique: on cherche un conteneur centré et relativement étroit
    const list = Array.from(document.querySelectorAll('main, [role="main"], #__next>div, body>div, body>main'));
    let best = null, bestScore = -1;
    for (const el of list){
      const r = el.getBoundingClientRect();
      const style = getComputedStyle(el);
      const centered = (style.marginLeft === 'auto' && style.marginRight === 'auto') ? 1 : 0;
      const w = r.width;
      const inRange = (w >= MIN_WIDTH && w <= MAX_WIDTH) ? 2 : 0;
      const score = (centered*2) + inRange + Math.min(w, 1000)/1000; // score simple
      if (score > bestScore) { bestScore = score; best = el; }
    }
    // fallback: 1er enfant de #__next ou du body
    return best || document.querySelector('#__next>*') || document.body.firstElementChild || null;
  }

  function ensureWrapper(el){
    if (el && el.parentElement && el.parentElement.id === 'phantom-fit-wrap') return el.parentElement;
    const wrap = document.createElement('div');
    wrap.id = 'phantom-fit-wrap';
    el.parentElement.insertBefore(wrap, el);
    wrap.appendChild(el);
    return wrap;
  }

  function fitOnce(){
    const target = findTarget();
    if (!target) return;
    const wrap = ensureWrapper(target);

    // largeur "naturelle" avant scale (si déjà scalé, on la récupère)
    const currentScale = target.__phantomScale || 1;
    const naturalWidth = target.getBoundingClientRect().width / currentScale;

    // facteur de zoom pour remplir la largeur de la fenêtre
    const scale = Math.min((window.innerWidth) / naturalWidth, MAX_SCALE);

    // applique le scale proprement
    target.style.transformOrigin = 'top center';
    target.style.transform = `scale(${scale})`;
    target.style.margin = '0 auto';
    target.style.width = naturalWidth + 'px'; // base non-scalée pour garder les proportions
    target.__phantomScale = scale;

    // réserver la hauteur pour que le flux ne se chevauche pas
    const natHeight = target.getBoundingClientRect().height / scale;
    wrap.style.height = (natHeight * scale) + 'px';

    // sécurité : fond global noir
    document.documentElement.style.background = '#0B0B14';
    document.body.style.background = '#0B0B14';
  }

  // On relance à l’arrivée du contenu (Next.js hydrate après le load)
  function afterHydrationTry(){
    fitOnce();
    // si le DOM change (SPA), on refit
    const mo = new MutationObserver(() => fitOnce());
    mo.observe(document.body, {childList:true, subtree:true});
  }

  window.addEventListener('load', () => {
    // premier fit, puis un autre un peu plus tard (après hydratation)
    fitOnce();
    setTimeout(afterHydrationTry, 600);
  });
  window.addEventListener('resize', () => requestAnimationFrame(fitOnce));
})();
</script>
